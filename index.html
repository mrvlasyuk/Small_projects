4,
                    (Math.random() - 0.5) * 0.4
                );
                
                // Determine final result
                die.result = Math.floor(Math.random() * 6) + 1;
            });
            
            // Animate for 3 seconds
            const startTime = Date.now();
            const duration = 3000;
            
            function animateRoll() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                dice.forEach(die => {
                    if (!die.isRolling) return;
                    
                    // Apply gravity
                    die.velocity.y -= 0.015;
                    
                    // Update position
                    die.mesh.position.add(die.velocity);
                    
                    // Update rotation
                    die.mesh.rotation.x += die.angularVelocity.x;
                    die.mesh.rotation.y += die.angularVelocity.y;
                    die.mesh.rotation.z += die.angularVelocity.z;
                    
                    // Floor collision
                    if (die.mesh.position.y < 0.75) {
                        die.mesh.position.y = 0.75;
                        die.velocity.y *= -0.5;
                        die.velocity.x *= 0.8;
                        die.velocity.z *= 0.8;
                        die.angularVelocity.multiplyScalar(0.8);
                        
                        // Stop if slow enough
                        if (Math.abs(die.velocity.y) < 0.05 && die.angularVelocity.length() < 0.05) {
                            die.isRolling = false;
                        }
                    }
                    
                    // Wall collision
                    if (Math.abs(die.mesh.position.x) > 8) {
                        die.velocity.x *= -0.6;
                        die.mesh.position.x = Math.sign(die.mesh.position.x) * 8;
                    }
                    if (Math.abs(die.mesh.position.z) > 5) {
                        die.velocity.z *= -0.6;
                        die.mesh.position.z = Math.sign(die.mesh.position.z) * 5;
                    }
                });
                
                if (progress < 1 || dice.some(d => d.isRolling)) {
                    requestAnimationFrame(animateRoll);
                } else {
                    // Snap to final rotation based on result
                    dice.forEach((die, index) => {
                        snapToResult(die, die.result);
                    });
                    
                    setTimeout(() => {
                        const total = dice.reduce((sum, die) => sum + die.result, 0);
                        document.getElementById('total').textContent = total;
                        document.getElementById('result').classList.add('show');
                        
                        btn.disabled = false;
                        btn.textContent = 'ðŸŽ² Ð‘Ð ÐžÐ¡Ð˜Ð¢Ð¬!';
                        isRolling = false;
                    }, 500);
                }
            }
            
            animateRoll();
        }

        function snapToResult(die, result) {
            const targetRotations = {
                1: { x: 0, y: 0, z: 0 },
                2: { x: 0, y: Math.PI / 2, z: 0 },
                3: { x: -Math.PI / 2, y: 0, z: 0 },
                4: { x: Math.PI / 2, y: 0, z: 0 },
                5: { x: 0, y: -Math.PI / 2, z: 0 },
                6: { x: Math.PI, y: 0, z: 0 }
            };
            
            const target = targetRotations[result];
            
            // Smooth animation to final position
            const startRot = die.mesh.rotation.clone();
            const startTime = Date.now();
            const duration = 300;
            
            function snap() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);
                
                die.mesh.rotation.x = startRot.x + (target.x - startRot.x) * ease;
                die.mesh.rotation.y = startRot.y + (target.y - startRot.y) * ease;
                die.mesh.rotation.z = startRot.z + (target.z - startRot.z) * ease;
                
                if (progress < 1) {
                    requestAnimationFrame(snap);
                }
            }
            
            snap();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle floating animation for idle dice
            if (!isRolling) {
                dice.forEach((die, index) => {
                    const time = Date.now() * 0.001;
                    die.mesh.position.y = 0.75 + Math.sin(time + index * 0.5) * 0.05;
                    die.mesh.rotation.y += 0.005;
                });
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Initialize on load
        window.addEventListener('load', init);
        
        // Initialize immediately if already loaded
        if (document.readyState === 'complete') {
            init();
        }
    </script>
</body>
                </html>
